# -*- coding: utf-8 -*-
"""Shock_capturing_shared_code.ipynb

Automatically generated by Colaboratory.
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt

# read data
filename = '../simulations/viscous/gmm_gradp_divv/RESULTS/Cylinder_0000300000.tec'
data_set = pd.read_csv(filename, delimiter='\s+',skiprows=3)
data_set = pd.DataFrame(data_set)

data_set.columns = ["x","y","z","Q1_x","Q1_y","Q5_x","Q5_y","rho_x","rho_y","p_x","p_y","divV","rho","rhou","rhov","rhow","rhoe","p","Mach","sensor","eID"]



# ----------------------------------------------------------------------- Data organizing
c=data_set.loc[:,'x']=='ZONE'
Zones=data_set[c]
z=Zones.index
data_set=data_set.dropna(subset=["x","y","z","Q1_x","Q1_y","Q5_x","Q5_y","rho_x","rho_y","p_x","p_y","divV","rho","rhou","rhov","rhow","rhoe","p","Mach","sensor","eID"])

data_set = data_set.astype('float64')

# Feature Space
data_set['Grad2_w1'] = data_set['Q1_x']**2 + data_set['Q1_y']**2
data_set['Grad2_w5'] = data_set['Q5_x']**2 + data_set['Q5_y']**2
data_set['Grad2_rho'] = data_set['rho_x']**2 + data_set['rho_y']**2
data_set['Grad2_p'] = data_set['p_x']**2 + data_set['p_y']**2
data_set['divV'] = data_set['divV']**2
data_set['region'] = [1]*len(data_set)


data_set['Grad2_w1'] = np.sqrt(data_set['Grad2_w1'])
data_set['Grad2_w5'] = np.sqrt(data_set['Grad2_w5'])
data_set['Grad2_rho'] = np.sqrt(data_set['Grad2_rho'])
data_set['Grad2_p'] = np.sqrt(data_set['Grad2_p'])
data_set['divV'] = np.sqrt(data_set['divV'])
data_set = pd.DataFrame(data_set)


# ----------------------------------------------------------------------- Data_normalization

from sklearn.preprocessing import MinMaxScaler

data = data_set.loc[:,('divV','Grad2_p')]
data = data.astype('float64')
# Create an instance of MinMaxScaler
scaler = MinMaxScaler()

# Normalize the data
normalized_data = scaler.fit_transform(data.values)

# Create a new DataFrame with normalized data
normalized_dt = pd.DataFrame(normalized_data, columns=data.columns)

# ----------------------------------------------------------------------- Gaussian Mixture

from sklearn.mixture import GaussianMixture
gmm=GaussianMixture(n_components=2,tol=0.001,reg_covar=1e-4,max_iter=100,verbose=True).fit(normalized_dt)
labels=gmm.predict(normalized_dt)
data_set['Clusters_gaussian_mixture']=labels

unique_clusters = data_set['Clusters_gaussian_mixture'].unique()
unique_clusters

# ----------------------------------------------------------------------- Plot Feature space in each cluster

import matplotlib.pyplot as plt
plt.clf()
plt.rcParams['text.usetex'] = True
plt.rcParams['text.latex.preamble'] = r'\usepackage{amsmath}'
plt.rcParams['font.family'] = 'serif'
plt.rcParams['font.size'] = 22


# Get unique cluster labels
unique_clusters = data_set['Clusters_gaussian_mixture'].unique()

# List of colors for each cluster
colors = ['#2D003C', '#FFC0CB', '#87CEEB', '#FF69B4', '#C934C3', 'b']

plt.figure(figsize=(10, 8))

# Plot data points for each cluster
for i in range(0, 2):
    subset = data_set[data_set['Clusters_gaussian_mixture'] == i]
    plt.scatter(subset['Grad2_p'], subset['divV'], label=f'Cluster {i+1}', color=colors[i])

plt.xlabel(r'$\lVert\nabla p\rVert^2$', fontsize=22)
plt.ylabel(r'$(\nabla\cdot\vec{v})^2$', fontsize=22)
plt.legend()

plt.gcf().tight_layout()
plt.savefig('/content/s22_clusters_plot.png', dpi=300)
plt.show()

# ----------------------------------------------------------------------- Plot clusters


from matplotlib import colors
import numpy as np
import matplotlib.pyplot as plt
import scipy as sc

plt.clf()
plt.rcParams['text.usetex'] = True
plt.rcParams['text.latex.preamble'] = r'\usepackage{amsmath}'
plt.rcParams['font.family'] = 'serif'
plt.rcParams['font.size'] = 22


nx = 3000  # I used higher resolution grid for smoother interpolation
ny = 1500
x = np.linspace(-5, 9, nx)
y = np.linspace(-7, 7, ny)

bounds = [0, 5, 10]
field_interpolated = sc.interpolate.griddata((data_set['x'], data_set['y']), data_set['Clusters_gaussian_mixture'], (X, Y), method='nearest')

cmap = plt.get_cmap('gray_r')

plt.figure(figsize=(28, 36), clear=True)  # for more resolution, I used larger figure size
plt.imshow(field_interpolated.T, cmap=cmap, origin='lower', extent=[min(x), max(x), min(y), max(y)], interpolation='bicubic')


cylinder_color = '#333333'
cylinder = plt.Circle((0, 0), 0.5, edgecolor=None, facecolor=cylinder_color)
plt.gcf().gca().add_artist(cylinder)

plt.axis('off')
plt.gcf().tight_layout()
plt.savefig('/content/pdf_s22_shocks2.pdf', bbox_inches='tight')
plt.show()

# ----------------------------------------------------------------------- Plot performane metrics


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.mixture import GaussianMixture
from sklearn.preprocessing import StandardScaler

plt.clf()
plt.rcParams['text.usetex'] = True
# plt.rcParams['text.usetex'] = False
plt.rcParams['text.latex.preamble'] = r'\usepackage{amsmath}'
plt.rcParams['font.family'] = 'serif'
plt.rcParams['font.size'] = 22

# Extract the features from the dataset
features = data_set.values

# Standardize the features
scaler = StandardScaler()
normalized_dt = scaler.fit_transform(features)

# Initialize lists to store the values of the performance metrics for each value of k
aic_values = []
bic_values = []

# Iterate over a range of k values, running GMM clustering for each value
for k in range(1, 7):
    # Fit GMM with 6 clusters
    gmm = GaussianMixture(n_components=k, tol=0.001, reg_covar=1e-4, max_iter=100, verbose=True)
    gmm.fit(normalized_dt)

    # Compute the performance metrics (AIC and BIC)
    aic_values.append(gmm.aic(normalized_dt))
    bic_values.append(gmm.bic(normalized_dt))

# Plot the AIC and BIC values in the same figure
plt.figure(figsize=(10, 8))
# plt.plot(range(1, 7), aic_values, label='AIC')
plt.plot(range(1, 7), bic_values,'black', linewidth=2.5)
plt.xlabel(r'Number of clusters', fontsize=22)
plt.ylabel(r'BIC Performance Metric', fontsize=22)
# plt.title('AIC and BIC Values')
plt.legend()
# plt.axis('off')
plt.gcf().tight_layout()
plt.savefig('/content/BIC_6.png',bbox_inches='tight',dpi=300,pad_inches = 0)
plt.show()









